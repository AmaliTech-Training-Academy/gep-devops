name: Backend CI/CD Pipeline

on:
  repository_dispatch:
    types: [backend-deployment]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: dev
        type: choice
        options:
          - dev
          - staging
          - prod
      services:
        description: 'Services to deploy (JSON array)'
        required: false
        default: '["auth-service", "notification-service"]'
        type: string

env:
  ENVIRONMENT: "${{ github.event.client_payload.environment || inputs.environment }}"
  BACKEND_REPO: "${{ github.event.client_payload.repository || 'AmaliTech-Training-Academy/gep-backend' }}"
  COMMIT_SHA: "${{ github.event.client_payload.sha || github.sha }}"
  AWS_REGION: eu-west-1
  # Terraform-managed naming convention
  ECS_CLUSTER: "event-planner-${{ github.event.client_payload.environment || inputs.environment }}-cluster"
  SERVICES_TO_DEPLOY: "${{ github.event.client_payload.services && toJson(github.event.client_payload.services) || inputs.services }}"

jobs:
  prepare:
    runs-on: [self-hosted, backend]
    outputs:
      services: ${{ steps.services.outputs.matrix }}
    steps:
      - name: Checkout Backend Code
        uses: actions/checkout@v4
        with:
          repository: ${{ env.BACKEND_REPO }}
          ref: ${{ env.COMMIT_SHA }}
          token: ${{ secrets.BACKEND_REPO_TOKEN }}

      - name: List Repository Contents
        run: |
          echo "Repository contents:"
          ls -la
          echo "Looking for service directories..."
          find . -maxdepth 2 -type d -name "*service*" || echo "No service directories found"

      - name: Discover Available Services
        id: services
        run: |
          # Only deploy auth-service (enabled in Terraform)
          echo 'matrix=["auth-service"]' >> "$GITHUB_OUTPUT"
          echo "Deploying services: auth-service"
          
          # Note: other services are disabled in Terraform
          echo "⚠️ Disabled services (not in Terraform): notification-service, booking-service, payment-service, event-service"

  build-and-test:
    needs: prepare
    runs-on: [self-hosted, backend]
    strategy:
      matrix:
        service: ${{ fromJson(needs.prepare.outputs.services) }}
    steps:
      - name: Checkout Backend Code
        uses: actions/checkout@v4
        with:
          repository: ${{ env.BACKEND_REPO }}
          ref: ${{ env.COMMIT_SHA }}
          token: ${{ secrets.BACKEND_REPO_TOKEN }}

      - name: Verify Java Environment
        run: |
          echo "Java version:"
          java --version
          echo "JAVA_HOME: $JAVA_HOME"
          echo "Maven version:"
          mvn --version
          export JAVA_HOME=$(readlink -f /usr/bin/java | sed "s:bin/java::")
          echo "Updated JAVA_HOME: $JAVA_HOME"

      - name: Debug Service Path
        run: |
          echo "Processing service: ${{ matrix.service }}"
          echo "Looking for directory: services/${{ matrix.service }}"
          ls -la services/ || echo "services/ directory not found"
          ls -la services/${{ matrix.service }} || echo "services/${{ matrix.service }} not found"

      - name: Build and Test Service
        run: |
          export JAVA_HOME=/usr/lib/jvm/java-21-openjdk-amd64
          export MAVEN_OPTS="-Dmaven.repo.local=$HOME/.m2/repository"
          cd services/${{ matrix.service }}
          mvn clean package -DskipTests

      - name: Security Scan (Trivy)
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: 'services/${{ matrix.service }}'

  build-and-push:
    needs: [prepare, build-and-test]
    runs-on: [self-hosted, backend]
    strategy:
      matrix:
        service: ${{ fromJson(needs.prepare.outputs.services) }}
    steps:
      - name: Checkout Backend Code
        uses: actions/checkout@v4
        with:
          repository: ${{ env.BACKEND_REPO }}
          ref: ${{ env.COMMIT_SHA }}
          token: ${{ secrets.BACKEND_REPO_TOKEN }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push Docker Image
        run: |
          cd services/${{ matrix.service }}
          REGISTRY="${{ steps.login-ecr.outputs.registry }}"
          
          # Use Terraform naming convention: event-planner-{env}-{service}
          REPO_NAME="event-planner-${{ env.ENVIRONMENT }}-${{ matrix.service }}"
          IMAGE_TAG="${{ env.COMMIT_SHA }}"
          
          echo "Building image: $REGISTRY/$REPO_NAME:$IMAGE_TAG"
          docker build -t "$REGISTRY/$REPO_NAME:$IMAGE_TAG" .
          docker push "$REGISTRY/$REPO_NAME:$IMAGE_TAG"
          
          # Also tag as latest (Terraform uses 'latest' by default)
          docker tag "$REGISTRY/$REPO_NAME:$IMAGE_TAG" "$REGISTRY/$REPO_NAME:latest"
          docker push "$REGISTRY/$REPO_NAME:latest"
          
          echo "✅ Pushed images:"
          echo "  - $REGISTRY/$REPO_NAME:$IMAGE_TAG"
          echo "  - $REGISTRY/$REPO_NAME:latest"

  deploy-to-ecs:
    needs: [prepare, build-and-push]
    runs-on: [self-hosted, backend]
    strategy:
      matrix:
        service: ${{ fromJson(needs.prepare.outputs.services) }}
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check and Activate Service
        run: |
          SERVICE_NAME="${{ matrix.service }}"
          CLUSTER_NAME="${{ env.ECS_CLUSTER }}"
          
          echo "🔍 Checking service $SERVICE_NAME in cluster $CLUSTER_NAME"
          
          # Check if service exists and get its status
          SERVICE_INFO=$(aws ecs describe-services \
            --cluster "$CLUSTER_NAME" \
            --services "$SERVICE_NAME" \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].{Status:status,DesiredCount:desiredCount}' \
            --output json 2>/dev/null || echo '{"Status":"NOT_FOUND"}')
          
          SERVICE_STATUS=$(echo $SERVICE_INFO | jq -r '.Status')
          DESIRED_COUNT=$(echo $SERVICE_INFO | jq -r '.DesiredCount')
          
          echo "Service status: $SERVICE_STATUS, Desired count: $DESIRED_COUNT"
          
          if [ "$SERVICE_STATUS" = "NOT_FOUND" ] || [ "$SERVICE_STATUS" = "null" ]; then
            echo "❌ Service $SERVICE_NAME not found in cluster $CLUSTER_NAME"
            aws ecs list-services --cluster "$CLUSTER_NAME" --region ${{ env.AWS_REGION }} --output table
            exit 1
          elif [ "$SERVICE_STATUS" = "INACTIVE" ] || [ "$DESIRED_COUNT" = "0" ]; then
            echo "🔄 Service $SERVICE_NAME is INACTIVE or scaled to 0. Scaling up..."
            
            # Scale up the service to 1 task
            aws ecs update-service \
              --cluster "$CLUSTER_NAME" \
              --service "$SERVICE_NAME" \
              --desired-count 1 \
              --region ${{ env.AWS_REGION }}
            
            echo "⏳ Waiting for service to become active..."
            aws ecs wait services-stable \
              --cluster "$CLUSTER_NAME" \
              --services "$SERVICE_NAME" \
              --region ${{ env.AWS_REGION }}
            
            echo "✅ Service $SERVICE_NAME is now active"
          elif [ "$SERVICE_STATUS" != "ACTIVE" ]; then
            echo "⚠️ Service $SERVICE_NAME is in unexpected state: $SERVICE_STATUS"
            exit 1
          else
            echo "✅ Service $SERVICE_NAME is already ACTIVE"
          fi

      - name: Deploy to ECS (Force New Deployment)
        run: |
          SERVICE_NAME="${{ matrix.service }}"
          CLUSTER_NAME="${{ env.ECS_CLUSTER }}"
          
          echo "🚀 Deploying $SERVICE_NAME to $CLUSTER_NAME"
          echo "📦 New image will be pulled from ECR (tag: latest)"
          
          # Force new deployment (ECS will pull latest image)
          aws ecs update-service \
            --cluster "$CLUSTER_NAME" \
            --service "$SERVICE_NAME" \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}
          
          echo "✅ Deployment initiated for $SERVICE_NAME"

      - name: Wait for Service Stability
        run: |
          SERVICE_NAME="${{ matrix.service }}"
          CLUSTER_NAME="${{ env.ECS_CLUSTER }}"
          
          echo "⏳ Waiting for service to stabilize..."
          aws ecs wait services-stable \
            --cluster "$CLUSTER_NAME" \
            --services "$SERVICE_NAME" \
            --region ${{ env.AWS_REGION }}
          
          echo "✅ Service $SERVICE_NAME is stable"

      - name: Store Previous Task Definition
        id: backup
        run: |
          SERVICE_NAME="${{ matrix.service }}"
          CLUSTER_NAME="${{ env.ECS_CLUSTER }}"
          
          # Get current task definition before deployment
          CURRENT_TASK_DEF=$(aws ecs describe-services \
            --cluster "$CLUSTER_NAME" \
            --services "$SERVICE_NAME" \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].taskDefinition' \
            --output text)
          
          echo "previous_task_def=$CURRENT_TASK_DEF" >> $GITHUB_OUTPUT
          echo "📋 Stored previous task definition: $CURRENT_TASK_DEF"

      - name: Get Deployment Status
        id: deployment_status
        run: |
          SERVICE_NAME="${{ matrix.service }}"
          CLUSTER_NAME="${{ env.ECS_CLUSTER }}"
          
          echo "📊 Service Status:"
          aws ecs describe-services \
            --cluster "$CLUSTER_NAME" \
            --services "$SERVICE_NAME" \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].{Status:status,Running:runningCount,Desired:desiredCount,Deployments:deployments[*].{Status:status,TaskDef:taskDefinition,Running:runningCount}}' \
            --output table

  # rollback-on-failure:
  #   needs: [prepare, deploy-to-ecs]
  #   if: failure()
  #   runs-on: [self-hosted, backend]
  #   strategy:
  #     matrix:
  #       service: ${{ fromJson(needs.prepare.outputs.services) }}
  #   steps:
  #     - name: Configure AWS Credentials
  #       uses: aws-actions/configure-aws-credentials@v4
  #       with:
  #         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         aws-region: ${{ env.AWS_REGION }}
  #
  #     - name: Rollback Deployment
  #       run: |
  #         SERVICE_NAME="${{ matrix.service }}"
  #         CLUSTER_NAME="${{ env.ECS_CLUSTER }}"
  #         
  #         echo "🔄 Rolling back $SERVICE_NAME due to deployment failure"
  #         
  #         # Get the previous stable task definition
  #         PREVIOUS_TASK_DEF=$(aws ecs describe-services \
  #           --cluster "$CLUSTER_NAME" \
  #           --services "$SERVICE_NAME" \
  #           --region ${{ env.AWS_REGION }} \
  #           --query 'services[0].deployments[?status==`PRIMARY`].taskDefinition' \
  #           --output text | head -1)
  #         
  #         if [ -n "$PREVIOUS_TASK_DEF" ] && [ "$PREVIOUS_TASK_DEF" != "None" ]; then
  #           echo "📋 Rolling back to task definition: $PREVIOUS_TASK_DEF"
  #           
  #           # Update service to use previous task definition
  #           aws ecs update-service \
  #             --cluster "$CLUSTER_NAME" \
  #             --service "$SERVICE_NAME" \
  #             --task-definition "$PREVIOUS_TASK_DEF" \
  #             --region ${{ env.AWS_REGION }}
  #           
  #           echo "⏳ Waiting for rollback to stabilize..."
  #           aws ecs wait services-stable \
  #             --cluster "$CLUSTER_NAME" \
  #             --services "$SERVICE_NAME" \
  #             --region ${{ env.AWS_REGION }}
  #           
  #           echo "✅ Rollback completed for $SERVICE_NAME"
  #         else
  #           echo "❌ No previous task definition found for rollback"
  #         fi
  notify:
    needs: [prepare, deploy-to-ecs]
    if: always()
    runs-on: [self-hosted, backend]
    steps:
      - name: Slack Notification
        uses: 8398a7/action-slack@v3
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        with:
          status: custom
          custom_payload: |
            {
              "text": "Backend Deployment Status",
              "attachments": [
                {
                  "color": "${{ contains(needs.*.result, 'failure') && 'danger' || 'good' }}",
                  "fields": [
                    {
                      "title": "Status",
                      "value": "${{ contains(needs.*.result, 'failure') && 'Failed' || 'Succeeded' }}",
                      "short": true
                    },
                    {
                      "title": "Environment",
                      "value": "${{ env.ENVIRONMENT }}",
                      "short": true
                    },
                    {
                      "title": "Services",
                      "value": "auth-service",
                      "short": true
                    },
                    {
                      "title": "Commit SHA",
                      "value": "${{ env.COMMIT_SHA }}",
                      "short": true
                    }
                  ]
                }
              ]
            }